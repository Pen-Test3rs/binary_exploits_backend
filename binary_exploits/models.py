from django.contrib.auth.models import AbstractUser
from django.db import models
from django.db.models import IntegerChoices

from django.utils.functional import cached_property
from martor.models import MartorField


class AppUser(AbstractUser):
    @cached_property
    def points(self):
        try:
            solutions = Solution.objects.filter(user=self)
            if not solutions.exists():
                return 0

            return sum(map(lambda sol: sol.task.points, solutions))
        except:
            return 0

    @cached_property
    def place(self):
        return len([el for el in AppUser.objects.all() if el.points > self.points]) + 1

    @cached_property
    def solved(self):
        return self.solutions.count()

class Category(models.Model):
    ordinal = models.IntegerField(blank=True, default=0, verbose_name='kolejność')
    name = models.CharField(max_length=256)
    description = models.TextField(default="", null=True, blank=True)

    class Meta:
        verbose_name = "kategoria"
        verbose_name_plural = "kategorie"

    def __str__(self):
        return f"{self.name}"


class Article(models.Model):
    ordinal = models.IntegerField(blank=True, default=0, verbose_name='kolejność')
    category = models.ForeignKey(Category, on_delete=models.CASCADE, related_name='articles', verbose_name='kategoria')
    name = models.CharField(max_length=256, default="", verbose_name='tytuł')
    excerpt = models.TextField(max_length=256, default="", verbose_name='fragment')
    content = MartorField()
    linked_tasks = models.ManyToManyField("Task", blank=True, related_name='articles_with_reference')

    @cached_property
    def tasks_count(self):
        return self.linked_tasks.count()

    class Meta:
        verbose_name = "artykuł"
        verbose_name_plural = "artykuły"

    def __str__(self):
        return f"{self.category.name}/{self.name}"


class Task(models.Model):
    name_id = models.CharField(max_length=100, unique=True, verbose_name='identyfikator')
    title = models.CharField(max_length=256, default="", verbose_name='tytuł zadania')
    description = MartorField()
    ordinal = models.IntegerField(blank=True, default=0, verbose_name='kolejność')
    articles = models.ManyToManyField("Article", blank=True, related_name="tasks_with_reference",
                                      verbose_name="artykuły")
    labels = models.ManyToManyField("TaskLabel", blank=True, related_name="tasks", verbose_name="tagi")
    level = models.IntegerField(default=5, verbose_name='poziom trudności')
    address = models.CharField(max_length=256, verbose_name='adres serwera z zadaniem')
    port = models.IntegerField()
    points = models.IntegerField(default=50, verbose_name='punkty')
    flag = models.CharField(max_length=256)
    required_tasks = models.ManyToManyField("Task", blank=True, related_name="is_requirement",
                                            verbose_name='wymagane zadania')
    attachments = models.ManyToManyField("TaskAttachment", related_name="task", verbose_name='pliki', blank=True)

    @cached_property
    def solutions_count(self):
        return self.solutions.count()

    class Meta:
        verbose_name = "zadanie"
        verbose_name_plural = "zadania"

    def __str__(self):
        return f"{self.id}: {self.title}"


class TaskAttachment(models.Model):
    file = models.FileField(upload_to="attachments/%Y/%m")

    class Meta:
        verbose_name = "załącznik"
        verbose_name_plural = "załączniki"

    def __str__(self):
        return f"{self.file.name}"


class TaskLabel(models.Model):
    name = models.CharField(max_length=100, unique=True, verbose_name="nazwa")

    class Meta:
        verbose_name = "tag"
        verbose_name_plural = "tagi"

    def __str__(self):
        return self.name


class Solution(models.Model):
    user = models.ForeignKey(AppUser, on_delete=models.CASCADE, related_name='solutions', verbose_name="użytkownik")
    task = models.ForeignKey(Task, on_delete=models.CASCADE, related_name='solutions', verbose_name="zadanie")
    date = models.DateTimeField(auto_now_add=True, blank=True)

    class Meta:
        verbose_name = "rozwiązanie zadania"
        verbose_name_plural = "rozwiązania zadań"

    def __str__(self):
        return f"{self.user} - [{self.task}]"


class TaskStatusEnum(IntegerChoices):
    OK = 0, 'OK'
    SOLVED = 1, 'Solved'
    BLOCKED = 2, 'Blocked'
