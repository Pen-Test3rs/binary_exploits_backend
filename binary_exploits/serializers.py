from django.contrib.auth import get_user_model
from rest_framework import serializers
from rest_framework.validators import UniqueValidator

from .models import AppUser, Article, Category, Task, Solution, TaskAttachment, TaskLabel


def get_task_status(user: AppUser, task: Task):
    solutions = Solution.objects.filter(user=user)
    solved = [el.task for el in solutions]
    if task in solved:
        return "solved"
    for requirement in task.required_tasks.all():
        if requirement not in solved:
            return "blocked"
    return "ok"


class TaskAttachmentSerializer(serializers.ModelSerializer):
    class Meta:
        model = TaskAttachment
        fields = "__all__"


class TaskLabelSerializer(serializers.ModelSerializer):
    def to_representation(self, tag):
        return tag.name

    class Meta:
        model = TaskLabel




class TaskBlockedSerializer(serializers.ModelSerializer):
    status = serializers.SerializerMethodField()
    attachements = serializers.SerializerMethodField()
    address = serializers.SerializerMethodField()
    port = serializers.SerializerMethodField()
    description = serializers.SerializerMethodField()
    solutions_count = serializers.ReadOnlyField()
    labels = TaskLabelSerializer(many=True, read_only=True)

    def get_status(self, task):
        return "blocked"

    def get_attachements(self, task):
        return []

    def get_description(self, task):
        return "Odblokuj zadanie, aby uzyskać więcej informacji"

    def get_address(self, task):
        return -1

    def get_port(self, task):
        return -1

    class Meta:
        model = Task
        exclude = ['flag']


class TaskListSolutionsSerializer(serializers.ModelSerializer):
    labels = TaskLabelSerializer(many=True, read_only=True)
    solutions_count = serializers.ReadOnlyField()

    class Meta:
        model = Task
        fields = ['id', 'name_id', 'title', 'level', 'labels', 'points', 'ordinal', 'solutions_count']


class TaskListSerializer(serializers.ModelSerializer):
    def get_status(self, task):
        user: AppUser = self.context['request'].user
        return get_task_status(user, task)

    labels = TaskLabelSerializer(many=True, read_only=True)
    status = serializers.SerializerMethodField()
    solutions_count = serializers.ReadOnlyField()

    class Meta:
        model = Task
        fields = ['id', 'name_id', 'title', 'level', 'labels', 'status', 'points', 'ordinal', 'solutions_count']


class TaskArticleField(serializers.Field):
    def to_representation(self, tasks):
        res = []
        for task in tasks.all():
            if get_task_status(self.context['request'].user, task) == 'blocked':
                res.append(TaskBlockedSerializer(task).data)
            else:
                res.append(TaskSerializer(task, context={'request': self.context['request']}).data)
        res = sorted(res, key=lambda x: int(x['ordinal']))
        return res


class SolutionsSerializer(serializers.ModelSerializer):
    task = TaskListSolutionsSerializer(read_only=True)

    class Meta:
        model = Solution
        fields = '__all__'


class UserFullSerializer(serializers.ModelSerializer):
    points = serializers.ReadOnlyField()
    place = serializers.ReadOnlyField()

    class Meta:
        model = get_user_model()
        fields = "__all__"


class UserSerializer(serializers.ModelSerializer):
    points = serializers.ReadOnlyField()
    place = serializers.ReadOnlyField()
    solutions = SolutionsSerializer(read_only=True, many=True)

    class Meta:
        model = get_user_model()
        fields = ['id', 'username', 'email', 'date_joined', 'points', 'solutions', 'place']


class UserPublicSerializer(serializers.ModelSerializer):
    points = serializers.ReadOnlyField()
    place = serializers.ReadOnlyField()
    solutions = SolutionsSerializer(read_only=True, many=True)

    class Meta:
        model = get_user_model()
        fields = ['id', 'username', 'date_joined', 'points', 'solutions', 'place']


class ArticleSerializer(serializers.ModelSerializer):
    linked_tasks = TaskArticleField(read_only=True)

    class Meta:
        model = Article
        fields = '__all__'


class ArticlePublicSerializer(serializers.ModelSerializer):
    class Meta:
        model = Article
        exclude = ['linked_tasks']


class ArticleListSerializer(serializers.ModelSerializer):
    class Meta:
        model = Article
        fields = ['id', 'name', 'ordinal', 'excerpt', 'tasks_count']


class ContentSerializer(serializers.ModelSerializer):
    articles = ArticleListSerializer(many=True, read_only=True)

    class Meta:
        model = Category
        fields = '__all__'

    def to_representation(self, instance):
        response = super().to_representation(instance)
        response["articles"] = sorted(response["articles"], key=lambda x: int(x["ordinal"]))
        return response


class UserUpdateSerializer(serializers.Serializer):
    email = serializers.EmailField(required=False)
    oldPassword = serializers.CharField(required=True)
    password = serializers.CharField(write_only=True, required=False)

    def validate_email(self, email):
        if email in [el.email for el in AppUser.objects.exclude(id=self.context['uid'])]:
            raise serializers.ValidationError("Adres e-mail musi być unikalny")
        return email


class UserRegisterSerializer(serializers.ModelSerializer):
    email = serializers.EmailField(
        required=True,
        validators=[UniqueValidator(queryset=AppUser.objects.all())]
    )
    points = serializers.ReadOnlyField()
    place = serializers.ReadOnlyField()
    solutions = SolutionsSerializer(many=True, read_only=True)

    password = serializers.CharField(write_only=True, required=True)

    class Meta:
        model = get_user_model()
        fields = ['id', 'username', 'email', 'groups', 'password', 'date_joined', 'points', 'solutions', 'place']
        extra_kwargs = {
            'email': {'required': True},
        }

    def create(self, validated_data):
        user = AppUser.objects.create(
            username=validated_data['username'],
            email=validated_data['email'],
        )
        user.set_password(validated_data['password'])
        user.save()
        return user


class TaskSolutionSerializer(serializers.Serializer):
    id = serializers.IntegerField(required=True)
    flag = serializers.CharField(required=True, max_length=256)

    def validate(self, data):
        if not Task.objects.filter(id=data['id']).exists():
            raise serializers.ValidationError("Invalid task id")
        user = self.context['request'].user

        task = Task.objects.get(id=data['id'])
        valid = False
        if data['flag'] == task.flag:
            valid = True
            if not Solution.objects.filter(user=user, task=task).exists():
                solution = Solution.objects.create(user=user, task=task, flag_sent=data['flag'])
                solution.save()
            else:
                raise serializers.ValidationError("Rozwiązanie zostało już wysłane")
        data['success'] = valid
        return data


class UserRatingListSerializer(serializers.ModelSerializer):

    def get_solved(self, user: AppUser):
        return user.solutions.count()

    points = serializers.ReadOnlyField()
    place = serializers.ReadOnlyField()
    solved = serializers.SerializerMethodField()

    class Meta:
        model = get_user_model()
        fields = ["id", "username", "points", "solved", "place"]


class TaskSerializer(serializers.ModelSerializer):
    def get_status(self, task):
        user: AppUser = self.context['request'].user
        return get_task_status(user, task)

    status = serializers.SerializerMethodField()
    attachments = TaskAttachmentSerializer(many=True, read_only=True)
    labels = TaskLabelSerializer(many=True, read_only=True)
    articles = ArticleListSerializer(many=True, read_only=True)
    solutions_count = serializers.ReadOnlyField()

    class Meta:
        model = Task
        exclude = ['flag']


class ActivitySolutionsSerializer(serializers.ModelSerializer):
    task = TaskListSolutionsSerializer(read_only=True)
    user = UserRatingListSerializer(read_only=True)

    class Meta:
        model = Solution
        exclude = ['flag_sent']

