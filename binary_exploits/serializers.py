from abc import ABC

from django.contrib.auth import get_user_model, authenticate
from django.contrib.auth.models import update_last_login
from rest_framework.settings import api_settings
from rest_framework.utils import json
from rest_framework_simplejwt.serializers import TokenObtainPairSerializer, login_rule, user_eligible_for_login, \
    PasswordField
from rest_framework_simplejwt.tokens import RefreshToken

from .models import AppUser, Subcategory, Category, Task
from rest_framework import serializers, exceptions
from rest_framework.validators import UniqueValidator


class UserFullSerializer(serializers.ModelSerializer):
    class Meta:
        model = get_user_model()
        fields = '__all__'


class TaskSerializer(serializers.ModelSerializer):
    class Meta:
        model = Task
        exclude = ['flag']
        # fields = '__all__'



class SubcategorySerializer(serializers.ModelSerializer):
    tasks = TaskSerializer(many=True, read_only=True)
    class Meta:
        model = Subcategory
        # fields = ['name', 'content', 'tasks']
        fields = '__all__'

class ContentSerializer(serializers.ModelSerializer):
    subcategories = SubcategorySerializer(many=True, read_only=True)
    class Meta:
        model = Category
        fields = ['name', 'description', 'subcategories']
        # fields = '__all__'




class UserRegisterSerializer(serializers.ModelSerializer):
    email = serializers.EmailField(
        required=True,
        validators=[UniqueValidator(queryset=AppUser.objects.all())]
    )

    password = serializers.CharField(write_only=True, required=True)

    class Meta:
        model = get_user_model()
        fields = ['id', 'username', 'email', 'groups', 'password']
        extra_kwargs = {
            'email': {'required': True},
        }

    def create(self, validated_data):
        user = AppUser.objects.create(
            username=validated_data['username'],
            email=validated_data['email'],
        )
        user.set_password(validated_data['password'])
        user.save()
        return user



class UserTokenSerializer(TokenObtainPairSerializer):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

    def validate(self, attrs):
        authenticate_kwargs = {
            self.username_field: attrs[self.username_field],
            'password': attrs['password'],
        }
        user = authenticate(**authenticate_kwargs)

        if not getattr(login_rule, user_eligible_for_login)(user):
            raise exceptions.AuthenticationFailed(
                self.error_messages['no_active_account'],
                'no_active_account',
            )
        refresh = self.get_token(user)
        data = {}
        data['refresh'] = str(refresh)
        data['access'] = str(refresh.access_token)
        return data
